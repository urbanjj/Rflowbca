---
title: "README.md"
output: md_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
# Introduction to flowbcaR
### *Jongjin Yun (2025-07-29)*

`flowbcaR` is an R implementation of the Stata package flowbca, a hierarchical clustering algorithm designed for flow data.

- This package is used to identify functional regions by analyzing interactions between units, such as population movement or trade.
- Beyond clustering, `flowbcaR` offers a comprehensive suite of tools for regional and social network analysis, including evaluation, diagnosis, and visualization.
- First, it provides indicators such as `modularity`, `inter_flow_ratio`, and `relative_g`, which allow users to compare clustering results at each steps.
- Second, it converts the cluster hierarchy into a textual format, making the structure easier to interpret.
- Third, it includes a function to bridge the gap between statistical clustering results and their geographic representation, linking clusters with spatial units.
- Additionally, `flowbcaR` supports stepwise animations to visualize the dynamic process of spatial clustering.

## Background and Methodology

The `flowbca` algorithm, developed by Meekes and Hassink (2018), is an agglomerative hierarchical clustering method that focuses on the **flow** between units.

The core idea is as follows:

1.  **Initial State**: Every unit (e.g., a city or county) starts as its own cluster.
2.  **Optimization Function**: At each step, the algorithm identifies the pair of units with the strongest interaction based on a chosen optimization function. This function can consider:
    -   **Directionality**: Directed (A -> B) or undirected (A <-> B) flows.
    -   **Scale**: Absolute flow volume or relative flow volume (as a proportion of total outflow).
3.  **Merging**: The unit with the smaller outflow in the pair is merged into the unit with the larger inflow, which becomes the new cluster's core.
4.  **Iteration**: This process repeats, merging pairs and recalculating flows for the new, larger clusters, until only one cluster remains or a user-defined stopping condition is met.

## Analysis Workflow

The functions in `flowbcaR` are designed to be used in a sequential workflow, where the output of one function serves as the input for the next. This allows for a comprehensive analysis, from initial clustering to final visualization.

```{r workflow-function, echo=FALSE, include = FALSE, eval =FALSE}
library(DiagrammeR)
library(DiagrammeRsvg)

diagram <- grViz("
digraph flowbcaR_flow {
  
  graph [rankdir = LR]

  subgraph cluster_input {
    label = '1. Input Data';
    style = dashed;
    A [label = 'flow_input\\n(OD data.frame)', shape = folder]
    B [label = 'KR_SiGun\\n(sf object)', shape = folder]
  }

  subgraph cluster_core {
    label = '2. Core Clustering';
    C [label = 'flowbca', shape = box, style = filled, fillcolor = lightblue]
  }

  subgraph cluster_analysis {
    label = '3. Analysis & Visualization';
    D [label = 'build_hierarchy', shape = box]
    E [label = 'flowbca_stat', shape = box]
    F [label = 'flowbca_plot', shape = box]
    G [label = 'flowbca_modularity', shape = box]
    H [label = 'flowbca_gis', shape = box]
    I [label = 'flowbca_ani', shape = box]
  }

  subgraph cluster_diagnosis {
    label = '4. All-in-One Diagnosis';
    J [label = 'flowbca_diagnosis', shape = box, style = filled, fillcolor = lightgray]
  }

  # Outputs
  C_out [label = 'bca_result\\n(list)', shape = note, color = blue]
  E_out [label = 'stat_data', shape = note, color = blue]
  H_out [label = 'gis_layers', shape = note, color = blue]

  # Edges
  A -> C
  C -> C_out

  C_out -> D [label = 'unit_set']
  C_out -> E [label = 'F_matrix_history']
  E -> E_out
  E_out -> F

  C_out -> G [label = 'unit_set &\\nF_matrix_history']

  C_out -> H [label = 'unit_set']
  B -> H
  H -> H_out
  H_out -> I [label = 'gis_layers']
  C_out -> I [label = 'unit_set']

  A -> J
}
")
diagram_svg <- export_svg(diagram)
writeLines(diagram_svg, "workflow.svg")
```
```{r workflow_plot, echo=FALSE, out.width="100%", fig.align = 'center'}
knitr::include_graphics("./man/figures/workflow.svg")
```

A typical workflow involves these steps:

1.  **`flowbca()`**: The core function that performs hierarchical clustering on the flow data.
2.  **`build_hierarchy()`**: Creates a textual representation of the cluster hierarchy, showing how individual units are merged.
3.  **`flowbca_stat()` & `flowbca_plot()`**: Calculate and visualize basic statistics (e.g., internal flow ratios) to help assess cluster cohesion at each step.
4.  **`flowbca_modularity()`**: Computes network modularity, an advanced metric used to assess the quality of clusters at each step, and to facilitate comparison with other network clustering algorithms.
5.  **`flowbca_diagnosis()`**: Provides a diagnostic dashboard and statistical outputs to compare clustering strategies based on relative and absolute flows, using metrics from `flowbca_stat` and `flowbca_modularity`.
6.  **`flowbca_gis()` & `flowbca_ani()`**: Generate spatial visualizations, creating maps of the clusters at different stages and animating the entire merging process.

## Sample Data

The package includes two datasets for the Si-Gun administrative units of South Korea.

-   **`OD_SiGun`**: Origin-Destination (OD) data representing passenger flow between 159 Si-Gun units.
-   **`KR_SiGun`**: An `sf` object containing the administrative boundaries for the 159 Si-Gun units.

Before using the data, it needs to be prepared. The `flowbca()` function requires a `data.frame` where the first column contains unique source unit IDs, and the remaining column names are the corresponding destination unit IDs.

```{r prepare-data, echo=TRUE}
library(flowbcaR)
library(sf)

# Load the sample datasets
data(OD_SiGun)
data(KR_SiGun)

# Prepare the flow data for the algorithm
# The first column must be the source unit ID, and the destination column
# names must match the source unit IDs.
# We remove the first column ("SiGun_CD") to meet this requirement.
flow_input <- OD_SiGun[, -1]
colnames(flow_input) <- c('SiGun_NM',flow_input[,1])

# Check the prepared data
print("Prepared OD Data for flowbca:")
print(flow_input[1:5, 1:6])
print(head(KR_SiGun))
```

## Core Functions

### `flowbca()`

This is the main function that runs the clustering algorithm. It follows the logic of Stata's `flowbca.ado` and allows setting various merging criteria and stopping conditions.

-   **Features**:
    -   Implements the complete `flowbca` logic, including the detailed tie-breaking rules from the original Mata(Stata) implementation.
    -   Offers four optimization functions (`opt_f`) for directed/undirected and relative/absolute flows.
        -   `opt_f = 1`: directed relative flows approach (default).
        -   `opt_f = 2`: undirected relative flows approach.
        -   `opt_f = 3`: directed absolute flows approach.
        -   `opt_f = 4`: undirected absolute flows approach.
    -   Provides multiple stopping conditions (`q`, `k`, `la`, `lw`, `lm`) for fine-grained control over the clustering process.
        -   `q`: The minimum flow threshold for merging clusters. A relative threshold is specified as a ratio, and an absolute threshold is specified as an integer. If the specified threshold is greater than the maximum value in the entire flow data, the algorithm's stopping condition is met, and the procedure terminates. The default is `q = 0`.
        -   `k`: The target number of clusters.
        -   `la`: the minimum average of the internal relative flows.
        -   `lw`: the minimum weighted average of the internal relative flows.
        -   `lm`: the minimum internal relative flow.
    -   `save_k`: Specifies whether to return the F_matrix and C_matrix for all iterations. Defaults to FALSE.

-   **Usage**:
```{r flowbca-example, cache=TRUE}
# Run clustering until the minimum internal relative flow (lm) is at least 0.1 (10%).
# save_k=TRUE is important to retain data for subsequent analysis functions.
bca_result <- flowbca(flow_input, non_zero=TRUE, save_k = TRUE)

# The result is a list containing:
# 1. unit_set: Details of cluster assignment for each unit.
# 2. cluster_set: Statistics for the final clusters.
# 3. F_matrix: The final aggregated flow matrix.
# 4. F_matrix_history: A list of matrices from each clustering round.
# 5. C_matrix_history: A list of transformation matrices.
str(bca_result$unit_set, 3)
str(bca_result$cluster_set, 3)
```

-   **Considerations**:
    -   The choice of `opt_f` and stopping criteria can significantly affect the results. It's often useful to experiment with different settings.
    -   For very large datasets (many thousands of units), the process can be computationally intensive.

### `build_hierarchy()`

This function processes the `unit_set` to make the clustering hierarchy explicit and easier to understand.

-   **Features**:
    -   Generates a clear, slash-separated path string for each unit (e.g., `TopCluster/SubCluster/Unit`).
    -   Calculates the hierarchy level (`h_level`) for each unit.
-   **Usage**:
```{r hierarchy-example}
# Build the hierarchy path from the result
hierarchy_data <- build_hierarchy(bca_result$unit_set)

# View the hierarchy for a few units
head(hierarchy_data[, c("sourceunit", "clusterid", "hierarchy", "h_level")])
```
-   **Pros**:
    -   Excellent for understanding the nested structure of the clusters.
    -   The output can be easily used with other packages like `data.tree` for visualization.
```{r data-tree-example, message=FALSE}
library(data.tree)
# Create a pathString for data.tree
hierarchy_data$pathString <- paste("Korea", hierarchy_data$hierarchy, sep="/")
tree <- as.Node(hierarchy_data, pathName="pathString")
# Print the top levels of the tree
print(tree, "level", limit=10)
# Explore the sub-tree structure for Busan
print(tree$Busan)
```

### `flowbca_stat()` & `flowbca_plot()`

These functions provide a statistical summary of cluster cohesion at each step of the algorithm. This helps to understand how the cohesion of the clusters changes.

-   **Features**:
    -   `flowbca_stat` calculates key metrics: mean, min, median, and max of the internal relative flow, which measures how "self-contained" the clusters are.
    It also computes the ratio of intra-cluster to inter-cluster flow. The ratio of intra-cluster refers to the proportion of total flows that occur within clusters, while the ratio of inter-cluster represents the proportion of flows that occur between clusters.
    Therefore, the sum of the intra-cluster and inter-cluster ratios is equal to 1.
    -   `flowbca_plot` visualizes these statistics, making it easy to see how cohesion changes as clusters merge.
    It automatically finds and annotates the intersection point where intra-cluster flow surpasses inter-cluster flow, a useful heuristic for identifying a natural number of clusters.
-   **Usage**:
```{r stat-plot-example, out.width="90%", fig.width=10, fig.height=5, fig.align = 'center'}
# Calculate internal flow statistics from the matrix history
stat_data <- flowbca_stat(bca_result$F_matrix_history)
str(stat_data)
# Plot the statistics
# The x-axis represents the round (number of clusters + 1)
# The plot is interactive when the number of points is small (<= 20)
flowbca_plot(stat_data)
```

-   **Considerations**
    -   These plots are diagnostic tools. There is no single "correct" number of clusters, but these statistics provide an evidence-based way to choose a meaningful partition.

### `flowbca_modularity()`

This function calculates network modularity for each step of the clustering, offering a robust measure of cluster quality.

-   Modularity is calculated using the extended version proposed by Arenas et al. (2007), which accounts for both weights and directionality (Fortunato, 2010).

$$
Q_{\text{modularity}} = \frac{1}{W} \sum_{ij} \left( 
W_{ij} - \frac{s_i^{\text{out}} s_j^{\text{in}}}{W} \right) \delta(C_i, C_j)
$$

- Where:
    -   $W_{ij}$ is the weight of the directed edge from node $i$ to node $j$.
    -   $s_i^{out} = \sum_j W_{ij}$ is the total outgoing weight from node $i$ (out-degree).
    -   $s_j^{in} = \sum_i W_{ij}$ is the total incoming weight to node $j$ (in-degree).
    -   $W = \sum_{ij} W_{ij}$ is the total weight of all edges in the network.
    -   $C_i$ and $C_j$ are the communities to which nodes $i$ and $j$ belong.
    -   $\delta(C_i, C_j)$ is the Kronecker delta, which is 1 if $C_i = C_j$ and 0 otherwise.

-   **Features**:
    -   Implements the standard modularity formula for directed networks.
    -   Higher modularity values (typically in the range of 0.3 to 0.7) indicate a strong community structure, where flows are dense within clusters but sparse between them.
-   **Usage**:
```{r modularity-example, out.width="60%", fig.width=8,fig.height=6, fig.align = 'center'}
# Calculate modularity for each round
modularity_data <- flowbca_modularity(bca_result$unit_set, bca_result$F_matrix_history)

# Plot modularity over rounds
plot(modularity_data$round, modularity_data$modularity, type='l',
        xlab="Round", ylab="Modularity", main="Modularity vs. Clustering Step",
        xlim=rev(range(as.integer(modularity_data$round))))
```

-   **Pros**
    -   Modularity is a widely accepted standard for evaluating community detection in networks.
    -   It provides a single, powerful metric to help identify the optimal number of clusters.

### `flowbca_diagnosis()`

This function offers a convenient way to run and directly compare clustering strategies based on relative and absolute flows side by side.

-   **Features**:
    -   Automatically runs `flowbca` for both relative (`opt_f=1` or `2`) and absolute (`opt_f=3` or `4`) flow measures.
    - The user must specify whether the network is directed or undirected.
    The default is directed = TRUE. If directed = FALSE, the function symmetrizes the input to represent an undirected network.
    -   Generates a 2x2 plot comparing key metrics: mean internal flow, relative `g` value (the optimization score), intra-flow ratio, and modularity.
    - The relative g value represents the proportion of each g compared to the maximum g value across all steps.
-   **Usage**:
```{r diagnosis-example, out.width="90%", fig.width=8,fig.height=7, fig.align = 'center'}
# Perform diagnosis for a directed graph
# This function calls flowbca internally, so it may take a moment
diagnosis_stat <- flowbca_diagnosis(flow_input, is_directed = TRUE)
# The function returns the statistics used for plotting
str(diagnosis_stat)
```
-   **Pros**
    -   Saves time by automating the comparison of different `flowbca` runs.
    -   The plots provide a comprehensive dashboard to decide which clustering approach (`relative` vs. `absolute`) is more appropriate for the data and to identify an optimal number of clusters. The "Significant Modularity" zone (0.3-0.7) is highlighted to guide interpretation.

### `flowbca_gis()`

This function bridges the gap between the statistical clustering results and their geographic representation. Combines the clustering results from `flowbca` with spatial data (`sf` object) to create merged polygon layers for each merging step.

-   **Features**:
    -   Merges the `unit_set` with an `sf` spatial object.
    -   Generates a list of `sf` objects, one for each round of the clustering, with polygons dissolved according to the merge history.
    -   Includes a helper function to remove internal holes from the merged polygons, resulting in cleaner maps.
-   **Usage**:
```{r gis-example, message=FALSE, warning=FALSE, out.width="90%", fig.width=10,fig.height=10, fig.align = 'center'}
# Generate merged spatial layers for each round.
# This can take a moment for many units.
# We use a named vector for join_col to map columns with different names.
gis_layers <- flowbca_gis(bca_result$unit_set, KR_SiGun, 
                            join_col = c('sourceunit' = 'SiGun_NM'))

# Plot the spatial clusters at different rounds
par(mfrow = c(2, 2), mar = c(0.1, 0.1, 1.5, 0.1))
plot(gis_layers$`160`["sourceunit"], key.pos = NULL, reset = FALSE, main = "Round 160 (Initial)")
plot(gis_layers$`100`["sourceunit"], key.pos = NULL, reset = FALSE, main = "Round 100")
plot(gis_layers$`50`["sourceunit"], key.pos = NULL, reset = FALSE, main = "Round 50")
plot(gis_layers$`14`["sourceunit"], key.pos = NULL, reset = FALSE, main = "Round 14 (Final)")
```

-   **Considerations**
    -   The process can be slow if the polygons are very complex or if there are many units and merge steps.

### `flowbca_ani()`

Creates a GIF animation to visualize the dynamic process of spatial clustering.

-   **Features**:
    -   Takes the output of `flowbca_gis` and `unit_set` to create an animated sequence of maps.
    -   Highlights the merging clusters at each step.
-   **Usage** (example is not run in vignette build):
```r
# This code is not evaluated here to save time, but you can run it locally.
# It will create a file named "flowbca_clustering.gif" in your working directory.

flowbca_ani(
    flowbca_gis = gis_layers,
    unit_set = bca_result$unit_set,
    filenm = "flowbca_clustering.gif",
    width = 800
)
```

```{r gif_plot, echo=FALSE, out.width="80%", fig.align = 'center'}
knitr::include_graphics("./man/figures/flowbca_clustering.gif")
```

-   **Pros**
    -   Creates a powerful and intuitive visualization, perfect for presentations and reports.
-   **Cons**
    -   Requires the `magick` package.
    -   Can be resource-intensive (memory and time) for high-resolution animations or a large number of frames.

## Pros and Cons of the `flowbca` Algorithm

The `flowbca` algorithm and its implementation in `flowbcaR` offer a powerful approach for functional regionalization, but it's important to understand its advantages and limitations.

### Pros

1.  **Intuitive and Theory-Driven**: The algorithm is based on the clear and logical principle of merging units with the strongest functional linkages. This makes the results easy to interpret and well-aligned with theories of regional science and economic geography.

2.  **Rich Hierarchical Information**: Unlike clustering methods that produce a single, flat partition, `flowbca` generates a full hierarchy of clusters. The `build_hierarchy()` function makes this structure explicit, allowing for analysis at multiple geographic scales (e.g., identifying local labor markets within broader economic regions).

3.  **Comprehensive Diagnostics**: `flowbcaR` provides a robust suite of tools to evaluate and validate the clustering results. The combination of `flowbca_stat()`, `flowbca_plot()`, `flowbca_modularity()`, and `flowbca_diagnosis()` allows users to make data-driven decisions about the most appropriate number of clusters and the best optimization strategy, which is a significant advantage over black-box methods.

4.  **Flexible and Adaptable**: The ability to choose between directed/undirected and relative/absolute flows (`opt_f` in `flowbca()`) makes the algorithm highly adaptable to different types of interaction data (e.g., migration, trade, commuting) and diverse research questions.

5.  **Powerful Visualization**: The package seamlessly integrates clustering results with spatial data. `flowbca_gis()` makes it easy to map the resulting regions, and `flowbca_ani()` provides a compelling, dynamic visualization of the clustering process, which is invaluable for communication and exploratory analysis.

### Cons

1.  **Greedy Approach**: The algorithm is "greedy," meaning it makes the locally optimal decision at each step (merging the strongest pair). This does not guarantee a globally optimal solution. An early merge that seems optimal at the time might lead to a less-than-ideal overall clustering structure later on.

2.  **Sensitivity to Parameters**: The final results can be highly sensitive to the initial choice of the optimization function (`opt_f`) and the stopping criteria. While `flowbca_diagnosis()` helps compare different scenarios, the underlying sensitivity means that careful justification for parameter choices is required.

3.  **Island Problem**: The algorithm performs best on well-connected networks. Spatial units with very weak or no flows to other units (so-called "islands") may remain isolated until the very end of the process and can be merged in ways that do not seem intuitive.

4.  **Computational Cost**: For very large datasets (e.g., thousands of spatial units), the iterative matrix calculations in `flowbca()`, `flowbca_modularity` and the geometric operations in `flowbca_gis()` can be computationally intensive and time-consuming.

## References

- Arenas, A., Duch, J., Fernández, A., & Gómez, S. (2007). Size reduction of complex networks preserving modularity. *New Journal of Physics*, *9*(6), 176.
- Fortunato, S. (2010). Community detection in graphs. *Physics Reports*, *486*(3–5), 75–174.
- Meekes, J., & Hassink, W. H. J. (2018). flowbca: A flow-based cluster algorithm in Stata. *The Stata Journal*, *18*(3), 564–584.
- Newman, M. E. (2003). The structure and function of complex networks. *SIAM Review*, *45*(2), 167–256.
