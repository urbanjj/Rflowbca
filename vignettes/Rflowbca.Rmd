---
title: "Using Rflowbca for Flow-based Regionalization"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using Rflowbca for Flow-based Regionalization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  warning = FALSE,
  message = FALSE
)
```

## Introduction

The `Rflowbca` package provides tools to perform flow-based hierarchical clustering, a method often used in geography and economics to delineate functional regions (e.g., labor market areas) based on origin-destination flow data.

This vignette demonstrates the full workflow of the package, from running the core clustering algorithm to visualizing the results statistically and spatially. We will use the example datasets `OD_SiGun` (flow data) and `KR_SiGun` (spatial data) included in the package.

```{r setup}
library(Rflowbca)
library(sf)
library(magick)
```

## 1. Loading Data

First, we load the necessary data. `OD_SiGun` is a data frame representing flows between regions (Si-Gun) in South Korea. `KR_SiGun` is an `sf` object containing the corresponding administrative boundaries.

```{r load_data}
# Load the origin-destination flow data
data(OD_SiGun)

# Load the spatial boundaries for the regions
data(KR_SiGun)

# Preview the datasets
head(OD_SiGun[, 1:6])

flow_data <- OD_SiGun[, -1]

summary(colnames(flow_data)[-1] == OD_SiGun[,1])

colnames(flow_data) <- c("sourceunit_nm",flow_data$sourceunit_nm)

head(flow_data[,1:5])

plot(st_geometry(KR_SiGun), main = "Administrative Boundaries (KR_SiGun)")
```

## 2. Running the Flow-based Clustering Algorithm

The core function of the package is `flowbca()`. It takes the flow data as input and performs hierarchical clustering. Here, we run the algorithm using threshold (lm = 0.1) to determine the final clusters, and set `save_k = TRUE` to retain the history of matrix transformations, which is needed for later statistical analysis.

```{r run_flowbca}
# Run the clustering algorithm
# We set threshold lm=0.1
# We use the default optimization function (opt_f=1, directed relative flows)
bca_result <- flowbca(flow_data, lm = 0.1, save_k = TRUE)

# The result is a list containing the unit assignments, cluster stats, and history
names(bca_result)
```

## 3. Exploring the Clustering Results

The `bca_result` object contains `unit_set` (detailing each unit's final cluster) and `cluster_set` (statistics for the final 10 clusters).

```{r explore_results}
# unit_set shows how each source unit was merged
head(bca_result$unit_set)

# cluster_set shows statistics for the final clusters
print(bca_result$cluster_set)
```

We can use `build_hierarchy()` to add a column showing the full merge path for each unit.

```{r build_hierarchy}
unit_set_h <- build_hierarchy(bca_result$unit_set)
head(unit_set_h[, c("sourceunit", "clusterid", "hierarchy", "h_level")])
```

## 4. Visualizing Clustering Statistics

To understand how the internal cohesion of clusters changes at each step, we can use `flowbca_stat()` and `flowbca_plot()`.

`flowbca_stat()` calculates summary statistics of internal relative flows for each clustering round from the matrix history.

```{r flowbca_stat}
# Calculate statistics from the matrix history
stat_data <- flowbca_stat(bca_result$F_matrix_history)
head(stat_data)
```

`flowbca_plot()` visualizes these statistics, allowing us to assess at which stage the clusters are most coherent.

```{r flowbca_plot}
# Plot the statistics
flowbca_plot(stat_data, upper_bound = 40)

flowbca_plot(stat_data, upper_bound = 20)
```
This plot helps identify an "elbow" or a point where the internal flow statistics change significantly, which can inform the choice of an optimal number of clusters.

## 5. Visualizing Spatial Clusters

To see the results on a map, we use `flowbca_gis()`. This function takes the `unit_set` from our result and the `KR_SiGun` spatial data to generate a list of `sf` objects, where each represents the merged polygons at a specific round of clustering.

```{r flowbca_gis}
# Generate the list of merged sf objects
gis_steps <- flowbca_gis(
  unit_set = bca_result$unit_set,
  unit_gis = KR_SiGun,
  join_col = c("sourceunit"="SiGun_NM")
)

# The result is a list of sf objects, named by the round number
head(names(gis_steps))
plot(gis_steps$`50`)
plot(gis_steps$`14`)
```

Now, let's plot the final 10 clusters. The `gis_steps` list is ordered from the last merge to the first, so the final state is the last element.

```{r plot_gis}
# The final state with 10 clusters corresponds to the last element of the list
final_clusters_gis <- gis_steps[[length(gis_steps)]]

# Plot the final clusters
plot(final_clusters_gis, 
     main = "Final Clusters")
```

## 6. Creating an Animation (Optional)

Finally, we can create a GIF animation of the entire clustering process using `flowbca_ani()`. This function uses the `gis_steps` and `unit_set` to generate a frame for each merge event.

**Note:** The following code will generate a GIF file in your working directory. It can be time-consuming depending on the number of steps. We set `eval=FALSE` here so the vignette builds quickly, but you can run it yourself.

```{r flowbca_ani, eval=FALSE}
# Create the animation
flowbca_ani(
  flowbca_gis = gis_steps,
  unit_set = bca_result$unit_set,
  filenm = "flowbca_clustering.gif",
  width = 800
)
```

This concludes the basic workflow of the `Rflowbca` package.