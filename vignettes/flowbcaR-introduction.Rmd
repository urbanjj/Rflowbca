---
title: "Introduction to flowbcaR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to flowbcaR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(flowbcaR)
library(sf)
```

### *Jongjin Yun (2025-07-28)*

`flowbcaR` is an R implementation of the Stata package `flowbca`, a hierarchical clustering algorithm for flow data. This package is used to identify functional regions by analyzing interactions (e.g., population movement, trade) between spatial units. `flowbcaR` provides a suite of tools for clustering, evaluation, and visualization to support regional analysis.

## Background and Methodology

The `flowbca` algorithm, developed by Meekes and Hassink (2018), is an agglomerative hierarchical clustering method that focuses on the **flow** between units.

The core idea is as follows:

1.  **Initial State**: Every unit (e.g., a city or county) starts as its own cluster.
2.  **Optimization Function**: At each step, the algorithm identifies the pair of units with the strongest interaction based on a chosen optimization function. This function can consider:
    -   **Directionality**: Directed (A -> B) or undirected (A <-> B) flows.
    -   **Scale**: Absolute flow volume or relative flow volume (as a proportion of total outflow).
3.  **Merging**: The unit with the smaller outflow in the pair is merged into the unit with the larger inflow, which becomes the new cluster's core.
4.  **Iteration**: This process repeats, merging pairs and recalculating flows for the new, larger clusters, until only one cluster remains or a user-defined stopping condition is met.

## Analysis Workflow

The functions in `flowbcaR` are designed to be used in a sequential workflow, where the output of one function serves as the input for the next. This allows for a comprehensive analysis, from initial clustering to final visualization.

```{r workflow-diagram-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("../man/figures/workflow-diagram.png")
```

A typical workflow involves these steps:

1.  **`flowbca()`**: The core function that performs hierarchical clustering on the flow data.
2.  **`build_hierarchy()`**: Creates a textual representation of the cluster hierarchy, showing how individual units are merged.
3.  **`flowbca_stat()` & `flowbca_plot()`**: Calculate and visualize basic statistics (e.g., internal flow ratios) to help assess cluster cohesion at each step.
4.  **`flowbca_modularity()`**: Calculates network modularity, a more advanced metric to evaluate the quality of the clusters at each step.
5.  **`flowbca_diagnosis()`**: Provides a diagnostic dashboard to compare different clustering strategies (e.g., relative vs. absolute flows) using the metrics from `flowbca_stat` and `flowbca_modularity`.
6.  **`flowbca_gis()` & `flowbca_ani()`**: Generate spatial visualizations, creating maps of the clusters at different stages and animating the entire merging process.

## Sample Data

The package includes two datasets for the Si-Gun administrative units of South Korea.

-   **`OD_SiGun`**: Origin-Destination (OD) data representing passenger flow between 159 Si-Gun units.
-   **`KR_SiGun`**: An `sf` object containing the administrative boundaries for the 159 Si-Gun units.

Before using the data, it needs to be prepared. The `flowbca()` function requires a `data.frame` where the first column contains unique source unit IDs, and the remaining column names are the corresponding destination unit IDs.

```{r prepare-data, echo=TRUE}
library(flowbcaR)
library(sf)

# Load the sample datasets
data(OD_SiGun)
data(KR_SiGun)

# Prepare the flow data for the algorithm
# The first column must be the source unit ID, and the destination column
# names must match the source unit IDs.
# We remove the first column ("SiGun_CD") to meet this requirement.
flow_input <- OD_SiGun[, -1]
colnames(flow_input) <- c('SiGun_NM',flow_input[,1])

# Check the prepared data
print("Prepared OD Data for flowbca:")
print(flow_input[1:5, 1:6])
print(head(KR_SiGun))
```

## Core Functions

### `flowbca()`

This is the main function that runs the clustering algorithm.

-   **Features**:
    -   Implements the complete `flowbca` logic, including the detailed tie-breaking rules from the original Mata implementation.
    -   Offers four optimization functions (`opt_f`) for directed/undirected and relative/absolute flows.
    -   Provides multiple stopping conditions (`q`, `k`, `la`, `lw`, `lm`) for fine-grained control over the clustering process.
-   **Usage**:
    ```{r flowbca-example, cache=TRUE}
    # Run clustering until the minimum internal relative flow (lm) is at least 0.1 (10%).
    # save_k=TRUE is important to retain data for subsequent analysis functions.
    bca_result <- flowbca(flow_input, lm = 0.1, save_k = TRUE)
    
    # The result is a list containing:
    # 1. unit_set: Details of cluster assignment for each unit.
    # 2. cluster_set: Statistics for the final clusters.
    # 3. F_matrix: The final aggregated flow matrix.
    # 4. F_matrix_history: A list of matrices from each clustering round.
    # 5. C_matrix_history: A list of transformation matrices.
    str(bca_result$unit_set, 3)
    str(bca_result$cluster_set, 3)
    ```

-   **Considerations**:
    -   The choice of `opt_f` and stopping criteria can significantly affect the results. It's often useful to experiment with different settings.
    -   For very large datasets (many thousands of units), the process can be computationally intensive.

### `build_hierarchy()`

This function processes the `unit_set` to make the clustering hierarchy explicit and easier to understand.

-   **Features**:
    -   Generates a clear, slash-separated path string for each unit (e.g., `TopCluster/SubCluster/Unit`).
    -   Calculates the hierarchy level (`h_level`) for each unit.
-   **Usage**:
    ```{r hierarchy-example}
    # Build the hierarchy path from the result
    hierarchy_data <- build_hierarchy(bca_result$unit_set)
    
    # View the hierarchy for a few units
    head(hierarchy_data[, c("sourceunit", "clusterid", "hierarchy", "h_level")])
    ```
-   **Pros**:
    -   Excellent for understanding the nested structure of the clusters.
    -   The output can be easily used with other packages like `data.tree` for visualization.
    ```{r data-tree-example, message=FALSE}
    library(data.tree)
    # Create a pathString for data.tree
    hierarchy_data$pathString <- paste("Korea", hierarchy_data$hierarchy, sep="/")
    tree <- as.Node(hierarchy_data, pathName="pathString")
    # Print the top levels of the tree
    print(tree, "level", limit=10)
    ## Explore the sub-tree structure for Busan
    print(tree$Busan)
    ```

### `flowbca_stat()` & `flowbca_plot()`

These functions provide a statistical summary of cluster cohesion at each step of the algorithm.

-   **Features**:
    -   `flowbca_stat` calculates key metrics: mean, min, median, and max of the internal relative flow, which measures how "self-contained" the clusters are. It also computes the ratio of intra-cluster to inter-cluster flow.
    -   `flowbca_plot` visualizes these statistics, making it easy to see how cohesion changes as clusters merge. It automatically finds and annotates the intersection point where intra-cluster flow surpasses inter-cluster flow, a useful heuristic for identifying a natural number of clusters.
-   **Usage**:
    ```{r stat-plot-example, fig.width=10, fig.height=5}
    # Calculate internal flow statistics from the matrix history
    stat_data <- flowbca_stat(bca_result$F_matrix_history)
    str(stat_data)
    # Plot the statistics
    # The x-axis represents the round (number of clusters + 1)
    # The plot is interactive when the number of points is small (<= 20)
    flowbca_plot(stat_data)
    ```
-   **Considerations**:
    -   These plots are diagnostic tools. There is no single "correct" number of clusters, but these statistics provide an evidence-based way to choose a meaningful partition.

### `flowbca_modularity()`

This function calculates network modularity for each step of the clustering, offering a robust measure of cluster quality.

-   **Features**:
    -   Implements the standard modularity formula for directed networks.
    -   Higher modularity values (typically in the range of 0.3 to 0.7) indicate a strong community structure, where flows are dense within clusters but sparse between them.
-   **Usage**:
    ```{r modularity-example}
    # Calculate modularity for each round
    modularity_data <- flowbca_modularity(bca_result$unit_set, bca_result$F_matrix_history)
    
    # Plot modularity over rounds
    plot(modularity_data$round, modularity_data$modularity, type='l',
         xlab="Round", ylab="Modularity", main="Modularity vs. Clustering Step",
         xlim=rev(range(as.integer(modularity_data$round))))
    ```
-   **Pros**:
    -   Modularity is a widely accepted standard for evaluating community detection in networks.
    -   It provides a single, powerful metric to help identify the optimal number of clusters.

### `flowbca_diagnosis()`

This function provides a convenient way to run and compare different clustering strategies side-by-side.

-   **Features**:
    -   Automatically runs `flowbca` for both relative (`opt_f=1` or `2`) and absolute (`opt_f=3` or `4`) flow measures.
    -   Generates a 2x2 plot comparing key metrics: mean internal flow, relative `g` value (the optimization score), intra-flow ratio, and modularity.
-   **Usage**:
    ```{r diagnosis-example, fig.width=8, fig.height=7}
    # Perform diagnosis for a directed graph
    # This function calls flowbca internally, so it may take a moment
    diagnosis_stat <- flowbca_diagnosis(flow_input, is_directed = TRUE)
    
    # The function returns the statistics used for plotting
    # str(diagnosis_stat)
    ```
-   **Pros**:
    -   Saves time by automating the comparison of different `flowbca` runs.
    -   The plots provide a comprehensive dashboard to decide which clustering approach (`relative` vs. `absolute`) is more appropriate for the data and to identify an optimal number of clusters. The "Significant Modularity" zone (0.3-0.7) is highlighted to guide interpretation.

### `flowbca_gis()`

This function bridges the gap between the statistical clustering results and their geographic representation.

-   **Features**:
    -   Merges the `unit_set` with an `sf` spatial object.
    -   Generates a list of `sf` objects, one for each round of the clustering, with polygons dissolved according to the merge history.
    -   Includes a helper function to remove internal holes from the merged polygons, resulting in cleaner maps.
-   **Usage**:
    ```{r gis-example, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
    # Generate merged spatial layers for each round.
    # This can take a moment for many units.
    # We use a named vector for join_col to map columns with different names.
    gis_layers <- flowbca_gis(bca_result$unit_set, KR_SiGun, 
                              join_col = c('sourceunit' = 'SiGun_NM'))
    
    # Plot the spatial clusters at different rounds
    par(mfrow = c(2, 2), mar = c(0.1, 0.1, 1.5, 0.1))
    plot(gis_layers$`160`["sourceunit"], key.pos = NULL, reset = FALSE, main = "Round 160 (Initial)")
    plot(gis_layers$`100`["sourceunit"], key.pos = NULL, reset = FALSE, main = "Round 100")
    plot(gis_layers$`50`["sourceunit"], key.pos = NULL, reset = FALSE, main = "Round 50")
    plot(gis_layers$`14`["sourceunit"], key.pos = NULL, reset = FALSE, main = "Round 14 (Final)")
    ```
-   **Considerations**:
    -   The process can be slow if the polygons are very complex or if there are many units and merge steps.

### `flowbca_ani()`

Creates a GIF animation to visualize the dynamic process of spatial clustering.

-   **Features**:
    -   Takes the output of `flowbca_gis` and `unit_set` to create an animated sequence of maps.
    -   Highlights the merging clusters at each step.
-   **Usage** (example is not run in vignette build):
    ```r
    # This code is not evaluated here to save time, but you can run it locally.
    # It will create a file named "flowbca_clustering.gif" in your working directory.
    
    flowbca_ani(
      flowbca_gis = gis_layers,
      unit_set = bca_result$unit_set,
      filenm = "flowbca_clustering.gif",
      width = 800
    )
    ```
-   **Pros**:
    -   Creates a powerful and intuitive visualization, perfect for presentations and reports.
-   **Cons**:
    -   Requires the `magick` package.
    -   Can be resource-intensive (memory and time) for high-resolution animations or a large number of frames.

## Pros and Cons of the `flowbca` Algorithm

The `flowbca` algorithm and its implementation in `flowbcaR` offer a powerful approach for functional regionalization, but it's important to understand its advantages and limitations.

### Pros

1.  **Intuitive and Theory-Driven**: The algorithm is based on the clear and logical principle of merging units with the strongest functional linkages. This makes the results easy to interpret and well-aligned with theories of regional science and economic geography.

2.  **Rich Hierarchical Information**: Unlike clustering methods that produce a single, flat partition, `flowbca` generates a full hierarchy of clusters. The `build_hierarchy()` function makes this structure explicit, allowing for analysis at multiple geographic scales (e.g., identifying local labor markets within broader economic regions).

3.  **Comprehensive Diagnostics**: `flowbcaR` provides a robust suite of tools to evaluate and validate the clustering results. The combination of `flowbca_stat()`, `flowbca_plot()`, `flowbca_modularity()`, and `flowbca_diagnosis()` allows users to make data-driven decisions about the most appropriate number of clusters and the best optimization strategy, which is a significant advantage over black-box methods.

4.  **Flexible and Adaptable**: The ability to choose between directed/undirected and relative/absolute flows (`opt_f` in `flowbca()`) makes the algorithm highly adaptable to different types of interaction data (e.g., migration, trade, commuting) and diverse research questions.

5.  **Powerful Visualization**: The package seamlessly integrates clustering results with spatial data. `flowbca_gis()` makes it easy to map the resulting regions, and `flowbca_ani()` provides a compelling, dynamic visualization of the clustering process, which is invaluable for communication and exploratory analysis.

### Cons

1.  **Greedy Approach**: The algorithm is "greedy," meaning it makes the locally optimal decision at each step (merging the strongest pair). This does not guarantee a globally optimal solution. An early merge that seems optimal at the time might lead to a less-than-ideal overall clustering structure later on.

2.  **Sensitivity to Parameters**: The final results can be highly sensitive to the initial choice of the optimization function (`opt_f`) and the stopping criteria. While `flowbca_diagnosis()` helps compare different scenarios, the underlying sensitivity means that careful justification for parameter choices is required.

3.  **Island Problem**: The algorithm performs best on well-connected networks. Spatial units with very weak or no flows to other units (so-called "islands") may remain isolated until the very end of the process and can be merged in ways that do not seem intuitive.

4.  **Computational Cost**: For very large datasets (e.g., thousands of spatial units), the iterative matrix calculations in `flowbca()`, `flowbca_modularity` and the geometric operations in `flowbca_gis()` can be computationally intensive and time-consuming.

## References

Meekes, J., & Hassink, W. H. J. (2018). flowbca: A flow-based cluster algorithm in Stata. *The Stata Journal*, *18*(3), 564â€“584.
