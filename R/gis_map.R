#' Create a Static Map of the Final Clusters
#'
#' Generates a static map of the final clusters from a `flowbca` analysis.
#'
#' @param unit_set A data frame from the `flowbca` result. Must contain `h_parent` and `h_level` from `build_hierarchy()`.
#' @param unit_gis An `sf` object with polygons corresponding to the units.
#' @param join_col Specifies the join key columns.
#' @param sub An integer specifying the level of sub-clusters to display. If NULL (default), all clusters are shown.
#' @param filenm The file name for the output image. If NULL, the plot is displayed but not saved.
#' @param width The width of the output image in pixels.
#' @return A list of `sf` objects for the clusters and core units.
#' @importFrom grDevices adjustcolor colors dev.off png
#' @importFrom graphics par points
#' @importFrom sf st_bbox st_centroid st_geometry
#' @importFrom stats aggregate
#' @export
flowbca_map <- function(unit_set, unit_gis, join_col = "sourceunit", sub = NULL, filenm = 'flowbca_map.png', width = 1000) {

  # --- Package Checks ---
  if (!requireNamespace("sf", quietly = TRUE)) stop("Package 'sf' is required.")
  use_ragg <- requireNamespace("ragg", quietly = TRUE)

  # --- 1. Input Validation & Column Name Parsing ---
  if (is.character(join_col) && !is.null(names(join_col)) && length(join_col) == 1) {
    unit_set_id_col <- names(join_col)[1]
    unit_gis_id_col <- join_col[1]
  } else if (is.character(join_col) && length(join_col) == 1) {
    unit_set_id_col <- join_col
    unit_gis_id_col <- join_col
  } else {
    stop("'join_col' must be a single string or a single named vector.")
  }

  required_set_cols <- c(unit_set_id_col, 'clusterid', 'core', 'h_parent', 'h_level')
  if (!all(required_set_cols %in% names(unit_set))) {
    stop("unit_set must contain columns: ", paste(required_set_cols, collapse = ", "), ". 'h_parent' and 'h_level' can be generated by 'build_hierarchy()'.")
  }
  if (!unit_gis_id_col %in% names(unit_gis)) {
    stop(paste("unit_gis must contain the join column:", unit_gis_id_col))
  }
  
  # --- Plotting Setup ---
  bbox <- sf::st_bbox(unit_gis)
  width_units  <- bbox["xmax"] - bbox["xmin"]
  height_units <- bbox["ymax"] - bbox["ymin"]
  aspect_ratio <- height_units / width_units
  png_width <- width
  png_height <- round(png_width * aspect_ratio)
  cex_scaler <- width / 1000
  lwd_scaler <- 0.0005 * width + 0.5

  # --- Data Preparation ---
  merged_gis <- merge(unit_gis, unit_set[,c('sourceunit','clusterid','core')], by.x = unit_gis_id_col, by.y = unit_set_id_col, all.x = TRUE)
  union_gis <- aggregate(merged_gis, by = list(clusterid = merged_gis$clusterid), FUN = function(x) x[1])
  cluster_gis <- remove_holes_sf(union_gis)[,c('clusterid')]
  core_gis <- unit_gis[unit_gis[[unit_gis_id_col]] %in% unit_set[unit_set$core==1,][[unit_set_id_col]],]
  core_gis_point <- sf::st_centroid(core_gis)
  g_colour <- grDevices::adjustcolor(sample(grDevices::colors(), length(cluster_gis$geometry)), alpha.f = 0.5)

  # --- Device Handling ---
  if (!is.null(filenm)) {
    if (use_ragg) {
      ragg::agg_png(filenm, width = png_width, height = png_height)
    } else {
      grDevices::png(filenm, width = png_width, height = png_height)
    }
  }

  # --- Plotting ---
  graphics::par(mar = c(0, 0, 0, 0))
  plot(cluster_gis$geom, col = g_colour, lwd = 1.5 * lwd_scaler)
  plot(core_gis$geom, col = NA, lwd = 0.5 * lwd_scaler, add = TRUE)
  graphics::points(core_gis_point$geom, type = 'p', pch = 17, col = 'blue', cex = 2 * cex_scaler)

  if (!is.null(filenm)) {
    grDevices::dev.off()
  }
  
  gis_list <- list(cluster_gis = cluster_gis, core_gis = core_gis)
  return(gis_list)
}

# Helper function from gis.R
remove_holes_sf <- function(sf_obj) {
  geom <- sf::st_geometry(sf_obj)
  new_geom <- sf::st_sfc(lapply(geom, function(geom) {
    if (inherits(geom, "POLYGON")) {
      sf::st_polygon(list(geom[[1]]))
    } else if (inherits(geom, "MULTIPOLYGON")) {
      sf::st_multipolygon(lapply(geom, function(p) list(p[[1]])))
    } else {
      geom
    }
  }), crs = sf::st_crs(sf_obj))
  sf::st_set_geometry(sf_obj, new_geom)
}

#' Create a Map for a Specific Number of Clusters (k)
#'
#' Generates a spatial map representing the state of clustering when a specific
#' number of clusters (`k`) existed. This allows for analysis at different stages
#' of the hierarchical process.
#'
#' @param unit_set A data frame from the `flowbca` result, containing `sourceunit`,
#'   `destinationunit`, and `round` columns.
#' @param unit_gis An `sf` object with polygons corresponding to the units.
#' @param n_clusters The desired number of clusters (`k`) to visualize.
#' @param join_col Specifies the join key columns.
#' @param filenm The file name for the output image. If NULL, the plot is displayed but not saved.
#' @param width The width of the output image in pixels.
#' @return An `sf` object containing the aggregated cluster polygons for the specified `n_clusters`.
#' @export
flowbca_map_k <- function(unit_set, unit_gis, n_clusters, join_col = "sourceunit", filenm = NULL, width = 1000) {

  # --- 1. Input Validation ---
  if (!requireNamespace("sf", quietly = TRUE)) stop("Package 'sf' is required.")
  use_ragg <- requireNamespace("ragg", quietly = TRUE)

  required_cols <- c("sourceunit", "destinationunit", "round")
  if (!all(required_cols %in% names(unit_set))) {
    stop("unit_set must contain 'sourceunit', 'destinationunit', and 'round' columns.")
  }
  if (is.character(join_col) && !is.null(names(join_col))) {
      unit_set_id_col <- names(join_col)[1]
      unit_gis_id_col <- join_col[1]
  } else {
      unit_set_id_col <- unit_gis_id_col <- join_col
  }
  if (!unit_gis_id_col %in% names(unit_gis)) {
    stop(paste("unit_gis must contain the join column:", unit_gis_id_col))
  }

  # --- 2. Reconstruct Cluster State for n_clusters ---
  # Start with each unit in its own cluster
  cluster_map <- setNames(as.character(unit_set$sourceunit), as.character(unit_set$sourceunit))

  # Identify merges that occurred when cluster count > n_clusters
  merges_to_apply <- unit_set[!is.na(unit_set$round) & unit_set$round > n_clusters, ]
  merges_to_apply <- merges_to_apply[order(merges_to_apply$round, decreasing = TRUE), ]

  # Apply merges iteratively to find the cluster state at n_clusters
  if (nrow(merges_to_apply) > 0) {
    for (i in 1:nrow(merges_to_apply)) {
      r <- merges_to_apply$sourceunit[i]
      s <- merges_to_apply$destinationunit[i]
      
      cluster_to_change <- cluster_map[r]
      new_cluster <- cluster_map[s]
      
      cluster_map[cluster_map == cluster_to_change] <- new_cluster
    }
  }

  clusters_at_k_df <- data.frame(
    sourceunit = names(cluster_map),
    cluster_at_k = cluster_map,
    stringsAsFactors = FALSE
  )
  names(clusters_at_k_df)[1] <- unit_set_id_col

  # --- 3. Merge with Spatial Data and Aggregate ---
  gis_with_k_clusters <- merge(unit_gis, clusters_at_k_df, by.x = unit_gis_id_col, by.y = unit_set_id_col)
  
  dissolved_sf <- aggregate(
    gis_with_k_clusters["cluster_at_k"],
    by = list(cluster_id = gis_with_k_clusters$cluster_at_k),
    FUN = function(x) x[1]
  )
  dissolved_sf <- remove_holes_sf(dissolved_sf)

  # --- 4. Plotting ---
  if (!is.null(filenm)) {
    bbox <- sf::st_bbox(dissolved_sf)
    aspect_ratio <- (bbox["ymax"] - bbox["ymin"]) / (bbox["xmax"] - bbox["xmin"])
    png_height <- round(width * aspect_ratio)
    if (use_ragg) {
      ragg::agg_png(filenm, width = width, height = png_height)
    } else {
      grDevices::png(filenm, width = width, height = png_height)
    }
  }

  g_colour <- grDevices::adjustcolor(sample(grDevices::colors(), nrow(dissolved_sf)), alpha.f = 0.7)
  graphics::par(mar = c(1, 1, 1, 1))
  plot(sf::st_geometry(dissolved_sf), col = g_colour, border = "white", main = paste("Clusters at k =", n_clusters))
  
  # Add labels
  centroids <- sf::st_centroid(dissolved_sf)
  graphics::text(centroids, labels = dissolved_sf$cluster_id, cex = 0.8)

  if (!is.null(filenm)) {
    grDevices::dev.off()
  }

  return(dissolved_sf)
}

#' Create a Map for a Specific Hierarchy Level
#'
#' Generates a map of clusters at a specified hierarchy level, based on a tree
#' structure created by `build_cluster_tree()`.
#'
#' @param cluster_tree A nested list from `build_cluster_tree()`.
#' @param unit_gis An `sf` object with polygons corresponding to the units.
#' @param level An integer specifying the hierarchy level to visualize.
#' @param join_col Specifies the join key column for `unit_gis`.
#' @param filenm The file name for the output image. If NULL, the plot is displayed but not saved.
#' @param width The width of the output image in pixels.
#' @return An `sf` object of the aggregated cluster polygons for the specified level.
#' @export
flowbca_map_level <- function(cluster_tree, unit_gis, level, join_col = "sourceunit", filenm = NULL, width = 1000) {

  # --- 1. Input Validation ---
  if (!requireNamespace("sf", quietly = TRUE)) stop("Package 'sf' is required.")
  use_ragg <- requireNamespace("ragg", quietly = TRUE)

  # --- 2. Helper functions to traverse the tree ---
  get_leaf_nodes <- function(node) {
    if (length(node) == 0) return(names(node))
    unlist(sapply(node, get_leaf_nodes, USE.NAMES = FALSE))
  }

  get_clusters_at_level <- function(node, current_level) {
    if (current_level == level) return(names(node))
    if (length(node) == 0) return(NULL)
    unlist(sapply(1:length(node), function(i) get_clusters_at_level(node[[i]], current_level + 1), USE.NAMES = FALSE))
  }

  # --- 3. Extract Clusters and their Units ---
  clusters_at_level <- get_clusters_at_level(cluster_tree, 1)
  
  unit_cluster_list <- lapply(clusters_at_level, function(cl_name) {
    # Find the cluster in the tree and get all its leaf nodes (original units)
    find_and_get_leaves <- function(node, node_name) {
      if (node_name %in% names(node)) return(get_leaf_nodes(node[[node_name]]))
      for (sub_node in node) {
        res <- find_and_get_leaves(sub_node, node_name)
        if (!is.null(res)) return(res)
      }
      return(NULL)
    }
    leaves <- find_and_get_leaves(cluster_tree, cl_name)
    # The cluster itself is a leaf if it has no children
    if (is.null(leaves) || length(leaves) == 0) leaves <- cl_name
    data.frame(unit = leaves, cluster_id = cl_name, stringsAsFactors = FALSE)
  })
  
  unit_to_cluster_df <- do.call(rbind, unit_cluster_list)
  names(unit_to_cluster_df)[1] <- join_col

  # --- 4. Merge with Spatial Data and Aggregate ---
  gis_with_level_clusters <- merge(unit_gis, unit_to_cluster_df, by = join_col)
  
  dissolved_sf <- aggregate(
    gis_with_level_clusters["cluster_id"],
    by = list(cluster_id = gis_with_level_clusters$cluster_id),
    FUN = function(x) x[1]
  )
  dissolved_sf <- remove_holes_sf(dissolved_sf)

  # --- 5. Plotting ---
  if (!is.null(filenm)) {
    bbox <- sf::st_bbox(dissolved_sf)
    aspect_ratio <- (bbox["ymax"] - bbox["ymin"]) / (bbox["xmax"] - bbox["xmin"])
    png_height <- round(width * aspect_ratio)
    if (use_ragg) {
      ragg::agg_png(filenm, width = width, height = png_height)
    } else {
      grDevices::png(filenm, width = width, height = png_height)
    }
  }

  g_colour <- grDevices::adjustcolor(sample(grDevices::colors(), nrow(dissolved_sf)), alpha.f = 0.7)
  graphics::par(mar = c(1, 1, 1, 1))
  plot(sf::st_geometry(dissolved_sf), col = g_colour, border = "white", main = paste("Clusters at Level", level))
  
  centroids <- sf::st_centroid(dissolved_sf)
  graphics::text(centroids, labels = dissolved_sf$cluster_id, cex = 0.8)

  if (!is.null(filenm)) {
    grDevices::dev.off()
  }

  return(dissolved_sf)
}