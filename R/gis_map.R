#' Create a Static Map of the Final Clusters
#'
#' Generates a static map of the final clusters from a `flowbca` analysis.
#'
#' @param unit_set A data frame from the `flowbca` result. Must contain `h_parent` and `h_level` from `build_hierarchy()`.
#' @param unit_gis An `sf` object with polygons corresponding to the units.
#' @param join_col Specifies the join key columns.
#' @param sub An integer specifying the level of sub-clusters to display. If NULL (default), all clusters are shown.
#' @param filenm The file name for the output image. If NULL, the plot is displayed but not saved.
#' @param width The width of the output image in pixels.
#' @return A list of `sf` objects for the clusters and core units.
#' @importFrom grDevices adjustcolor colors dev.off png
#' @importFrom graphics par points
#' @importFrom sf st_bbox st_centroid st_geometry
#' @importFrom stats aggregate
#' @export
flowbca_map <- function(unit_set, unit_gis, join_col = "sourceunit", sub = NULL, filenm = 'flowbca_map.png', width = 1000) {

  # --- Package Checks ---
  if (!requireNamespace("sf", quietly = TRUE)) stop("Package 'sf' is required.")
  use_ragg <- requireNamespace("ragg", quietly = TRUE)

  # --- 1. Input Validation & Column Name Parsing ---
  if (is.character(join_col) && !is.null(names(join_col)) && length(join_col) == 1) {
    unit_set_id_col <- names(join_col)[1]
    unit_gis_id_col <- join_col[1]
  } else if (is.character(join_col) && length(join_col) == 1) {
    unit_set_id_col <- join_col
    unit_gis_id_col <- join_col
  } else {
    stop("'join_col' must be a single string or a single named vector.")
  }

  required_set_cols <- c(unit_set_id_col, 'clusterid', 'core')
  if (!all(required_set_cols %in% names(unit_set))) {
    stop("unit_set must contain columns: ", paste(required_set_cols, collapse = ", "), ". 'h_parent' and 'h_level' can be generated by 'build_hierarchy()'.")
  }
  if (!unit_gis_id_col %in% names(unit_gis)) {
    stop(paste("unit_gis must contain the join column:", unit_gis_id_col))
  }
  
  # --- Plotting Setup ---
  bbox <- sf::st_bbox(unit_gis)
  width_units  <- bbox["xmax"] - bbox["xmin"]
  height_units <- bbox["ymax"] - bbox["ymin"]
  aspect_ratio <- height_units / width_units
  png_width <- width
  png_height <- round(png_width * aspect_ratio)
  cex_scaler <- width / 1000
  lwd_scaler <- 0.0005 * width + 0.5

  # --- Data Preparation ---
  merged_gis <- merge(unit_gis, unit_set[,c('sourceunit','clusterid','core')], by.x = unit_gis_id_col, by.y = unit_set_id_col, all.x = TRUE)
  union_gis <- aggregate(merged_gis, by = list(clusterid = merged_gis$clusterid), FUN = function(x) x[1])
  cluster_gis <- remove_holes_sf(union_gis)[,c('clusterid')]
  core_gis <- unit_gis[unit_gis[[unit_gis_id_col]] %in% unit_set[unit_set$core==1,][[unit_set_id_col]],]
  core_gis_point <- sf::st_centroid(core_gis)
  g_colour <- grDevices::adjustcolor(sample(grDevices::colors(), length(cluster_gis$geometry)), alpha.f = 0.5)

  # --- Device Handling ---
  if (!is.null(filenm)) {
    if (use_ragg) {
      ragg::agg_png(filenm, width = png_width, height = png_height)
    } else {
      grDevices::png(filenm, width = png_width, height = png_height)
    }
  }

  # --- Plotting ---
  graphics::par(mar = c(0, 0, 0, 0))
  plot(cluster_gis$geom, col = g_colour, lwd = 1.5 * lwd_scaler)
  plot(core_gis$geom, col = NA, lwd = 0.5 * lwd_scaler, add = TRUE)
  graphics::points(core_gis_point$geom, type = 'p', pch = 17, col = 'blue', cex = 2 * cex_scaler)

  if (!is.null(filenm)) {
    grDevices::dev.off()
  }
  
  gis_list <- list(cluster_gis = cluster_gis, core_gis = core_gis)
  return(gis_list)
}

# Helper function from gis.R
remove_holes_sf <- function(sf_obj) {
  geom <- sf::st_geometry(sf_obj)
  new_geom <- sf::st_sfc(lapply(geom, function(geom) {
    if (inherits(geom, "POLYGON")) {
      sf::st_polygon(list(geom[[1]]))
    } else if (inherits(geom, "MULTIPOLYGON")) {
      sf::st_multipolygon(lapply(geom, function(p) list(p[[1]])))
    } else {
      geom
    }
  }), crs = sf::st_crs(sf_obj))
  sf::st_set_geometry(sf_obj, new_geom)
}