#' Create a Static Map of the Final Clusters
#'
#' Generates a static map of the final clusters from a `flowbca` analysis.
#'
#' @param unit_set A data frame from the `flowbca` result. Must contain `h_parent` and `h_level` from `build_hierarchy()`.
#' @param unit_gis An `sf` object with polygons corresponding to the units.
#' @param join_col Specifies the join key columns.
#' @param file_nm The file name for the output GIF. "The default value is set to
#'   the name of unit_set, but the user can specify it (e.g., flowbca_map.png)."
#' @param width The width of the output image in pixels.
#' @return A list of `sf` objects for the clusters and core units.
#' @importFrom grDevices adjustcolor colors dev.off png
#' @importFrom graphics par points
#' @importFrom sf st_bbox st_centroid st_geometry
#' @importFrom stats aggregate
#' @export
flowbca_map <- function(unit_set, unit_gis, join_col = "sourceunit", file_nm = NULL, width = 1000) {

  # --- Package Checks ---
  if (!requireNamespace("sf", quietly = TRUE)) stop("Package 'sf' is required.")
  use_ragg <- requireNamespace("ragg", quietly = TRUE)

  # --- 1. Input Validation & Column Name Parsing ---
  if (is.character(join_col) && !is.null(names(join_col)) && length(join_col) == 1) {
    unit_set_id_col <- names(join_col)[1]
    unit_gis_id_col <- join_col[1]
  } else if (is.character(join_col) && length(join_col) == 1) {
    unit_set_id_col <- join_col
    unit_gis_id_col <- join_col
  } else {
    stop("'join_col' must be a single string or a single named vector.")
  }

  if ((!is.null(file_nm) || nchar(as.character(file_nm)) != 0) & grepl('\\.png$', file_nm) == FALSE) {
    stop('The file name is required to have the .png extension.')
  }

  if (is.null(file_nm) || nchar(as.character(file_nm)) == 0) {
    file_nm <- paste0(deparse(substitute(unit_set)),'_map.png')
  }

  # required_set_cols <- c(unit_set_id_col, 'clusterid', 'core')
  if ("clusterid" %in% names(unit_set)) {
    required_set_cols <- c(unit_set_id_col, "clusterid", "core")
  } else if ("h_cl" %in% names(unit_set)) {
    required_set_cols <- c(unit_set_id_col, "h_cl", "core")
    unit_set <- unit_set[unit_set$h_cl %in% unit_set[unit_set$core!=0,]$h_cl,]
  } else {
    stop("Neither 'clusterid' nor 'h_cl' found in the dataframe.")
  }
  
  if (!all(required_set_cols %in% names(unit_set))) {
    stop("unit_set must contain columns: ", paste(required_set_cols, collapse = ", "), ". 'h_parent' and 'h_level' can be generated by 'build_hierarchy()'.")
  }
  if (!unit_gis_id_col %in% names(unit_gis)) {
    stop(paste("unit_gis must contain the join column:", unit_gis_id_col))
  }
  
  unit_set <- unit_set[,required_set_cols]
  names(unit_set) <- c(unit_set_id_col, "clusterid", "core")
  
  # --- Plotting Setup ---
  bbox <- sf::st_bbox(unit_gis)
  width_units  <- bbox["xmax"] - bbox["xmin"]
  height_units <- bbox["ymax"] - bbox["ymin"]
  aspect_ratio <- height_units / width_units
  png_width <- width
  png_height <- round(png_width * aspect_ratio)
  cex_scaler <- width / 1000
  lwd_scaler <- 0.0005 * width + 0.5

  # --- Data Preparation ---
  merged_gis <- merge(unit_gis, unit_set[,c('sourceunit','clusterid','core')], by.x = unit_gis_id_col, by.y = unit_set_id_col, all.x = TRUE)
  union_gis <- aggregate(merged_gis, by = list(clusterid = merged_gis$clusterid), FUN = function(x) x[1])
  cluster_gis <- remove_holes_sf(union_gis)[,c('clusterid')]
  core_gis <- unit_gis[unit_gis[[unit_gis_id_col]] %in% unit_set[unit_set$core==1,][[unit_set_id_col]],]
  core_gis_point <- sf::st_centroid(core_gis)
  core_gis_point_xy <- sf::st_coordinates(core_gis_point)
  g_colour <- grDevices::adjustcolor(sample(grDevices::colors(), length(cluster_gis$geometry)), alpha.f = 0.5)

  # --- Device Handling ---
  if (!is.null(file_nm)) {
    if (use_ragg) {
      ragg::agg_png(file_nm, width = png_width, height = png_height)
    } else {
      grDevices::png(file_nm, width = png_width, height = png_height)
    }
  }

  # --- Plotting ---
  graphics::par(mar = c(0, 0, 0, 0))
  plot(unit_gis$geom, col = 'white', lwd = 1 * lwd_scaler, border='grey50')
  plot(core_gis$geom, col = NA, lwd = 1 * lwd_scaler, add = TRUE, border = 'blue')
  plot(cluster_gis$geom, col = g_colour, lwd = 1.25 * lwd_scaler, add = TRUE)
  graphics::points(core_gis_point_xy[,1],core_gis_point_xy[,2], type = 'p', pch = 17, col = 'blue', cex = 2 * cex_scaler)

  if (!is.null(file_nm)) {
    grDevices::dev.off()
  }
  
  img <- magick::image_read(file_nm)
  plot(img)

  gis_list <- list(img=img,cluster_gis = cluster_gis, core_gis = core_gis)
  return(gis_list)
}

